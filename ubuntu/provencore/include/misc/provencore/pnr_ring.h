#ifndef PNR_RING_H
#define PNR_RING_H

/**
 * @mainpage pnr_ring
 *
 * pnr_ring is a C library implementing generic unidirectional and bidirectional
 * ring buffer data structures, consisting of a single header file, pnr_ring.h.
 */

/**
 * @file
 * @copyright Prove & Run and/or its affiliates. All rights reserved.
 * @date 2016--2019
 * @author Olivier Delande
 *
 * @brief Unidirectional and bidirectional ring buffers.
 *
 * This header implements generic unidirectional and bidirectional ring buffer
 * structures for asynchronous communication between two actors.
 *
 * In a unidirectional ring buffer, a *producer* writes messages in the ring,
 * and a *consumer* reads them.
 *
 * In a bidirectional ring buffer, a *client* writes requests in the ring, a
 * *server* reads them and overwrites them with responses, which the client
 * finally reads.
 *
 * Both kinds of ring buffers are meant to be used in conjunction with a
 * notification mechanism through which actors can signal key events to the
 * other end:
 *
 * Kind of ring buffer | Emitter  | Recipient | Signaled event                                                      |
 * ------------------- | -------- | --------- | ------------------------------------------------------------------- |
 * Unidirectional      | Producer | Consumer  | Message produced in a previously empty ring                         |
 * Unidirectional      | Consumer | Producer  | Message consumed from a previously full ring                        |
 * Bidirectional       | Client   | Server    | Request produced in a ring previously without unconsumed requests   |
 * Bidirectional       | Server   | Client    | Response produced in a ring previously without unconsumed responses |
 *
 * In a unidirectional ring buffer, the producer does not wait for any response
 * from the consumer.
 *
 * In a bidirectional ring buffer, there must be **exactly one response for each
 * request**. The ring buffer itself does not track which response corresponds
 * to which request, though. Users may build a communication protocol where the
 * server sends responses out of order, but they must implement a tracking
 * mechanism (e.g. by embedding an identifier in each request and response, and
 * have the server tag each response with the same identifier as the request it
 * responds to).
 *
 * A ring buffer consists of three data structures:
 * - a structure shared by the two actors, typically placed in shared memory;
 * - a structure private to each actor.
 *
 * The implementation of a type of ring buffer is generated by a call to a
 * macro: PNR_RING_GENERATE_UNI() for a unidirectional one;
 * PNR_RING_GENERATE_BI() for a bidirectional one.
 *
 * The documentation for the generated symbols is found in the source code of
 * the macro.
 *
 * Unidirectional vs bidirectional ring buffers
 * ============================================
 *
 * Whether a unidirectional or bidirectional ring buffer is more appropriate
 * depends on the situation.
 *
 * If messages are sent in one direction only (i.e. there is no response), then
 * a unidirectional ring buffer is the only choice.
 *
 * If there are messages in both directions, but these directions are
 * independent (e.g. in a network communication where packets are independently
 * sent and received), then two independent unidirectional ring buffers are the
 * only choice.
 *
 * If there are messages in both directions, with one direction sending requests
 * and the other direction sending back exactly one response per request, then
 * two solutions are possible:
 * - either a bidirectional ring buffer,
 * - or two undirectional ring buffers (one for requests, one for responses).
 *
 * A bidirectional ring buffer uses less memory, because it reuses the space
 * previously occupied by a request for a response, exploiting the fact that the
 * server never sends a response before it has received and processed the
 * corresponding request. It also makes throttling easier for the server: if the
 * server is flooded by requests and does not respond fast enough, then the ring
 * fills up and the client has no choice but to wait. The number of outstanding
 * requests cannot exceed the capacity (number of slots) of the ring buffer.
 *
 * By contrast, two unidirectional ring buffers use more memory, but induce less
 * cache coherency overhead, because each ring is written to by a single actor.
 * Also, the communication rates of the two rings are unrelated, which forces
 * the server to implement its own throttling: if the server is flooded by
 * requests and does not respond fast enough, it must be careful not to consume
 * requests indefinitely; at some point it has to wait until it has sent some
 * responses before accepting more requests.
 *
 * Basic usage
 * ===========
 *
 * The overall usage is the same for all ring buffers.
 *
 * First, define the types of transferred data: a single *message* type for a
 * unidirectional ring buffer, and two separate *request* and *response* types
 * for a bidirectional ring buffer. Take the usual precautions with binary
 * protocols (e.g. preferably use fixed-size integer types, implement
 * indirections with offsets rather than pointers, eliminate padding, etc.).
 *
 * Second, call the appropriate macro to generate the implementation of the ring
 * buffer. The call generates type and function definitions implementing ring
 * buffers transferring the messages/requests/responses of the chosen type(s).
 *
 * Third, decide which segment of shared memory to use for the shared structure,
 * and which actor gets to initialize the shared structure. That actor must call
 * the generated \c *_shared_init() function to do so. Each actor must allocate
 * its private structure (of type \c *_producer_t, \c *_consumer_t,
 * \c *_client_t, or \c *_server_t) and initialize it with the appropriate
 * function. An actor may only start communicating after it has initialized its
 * private structure **and** the shared structure has been initialized. You
 * therefore need an external synchronization mechanism with which the actor
 * responsible for initializing the shared structure can let the other know that
 * it has done so.
 *
 * Fourth, each actor must register a handler for the notifications from the
 * other end (see the table above for the events signaled through those
 * notifications). The producer of a unidirectional ring buffer (resp. the
 * client of a bidirectional ring buffer) does not expect to receive a
 * notification before it has started producing messages (resp. requests), but
 * the consumer (resp. server) may well have missed some notifications before it
 * registered its handler: the producer (resp. client) may have already produced
 * some messages (resp. requests). As a result, it is generally good practice
 * for the consumer (resp. server) to explicitly run its handler once at the end
 * of initialization, to take care of any missed notifications.
 *
 * Finally, communication can begin. Upon receiving a notification from the
 * other end, an actor typically checks out what the other end has been up to by
 * calling the appropriate \c *_checkout() function in a loop until no events
 * remain; at each iteration, it consumes messages/requests/responses by calling
 * the appropriate \c *_consume() function in a loop, then makes this
 * consumption visible to the other end with a call to the appropriate
 * \c *_commit() function. See the following sections for details.
 *
 * Some synchronization and security considerations apply. Refer to the
 * dedicated sections below.
 *
 * Unidirectional ring buffers
 * ---------------------------
 *
 * Both producer and consumer must define the implementation of the ring buffer:
 * ~~~{.c}
 * // Our type of messages
 * typedef ... mymsg_t;
 *
 * // Generate the implementation of the ring buffer
 * PNR_RING_GENERATE_UNI(mymsg_t, myring)
 * ~~~
 *
 * Let us suppose that the actors have agreed to place the shared structure (of
 * type \c myring_shared_t) in a segment of shared memory of size \c shared_size
 * bytes. Each actor has a private suitably aligned pointer \c pshared to this
 * segment (the two pointers may live in different address spaces). The size of
 * the segment will determine the capacity of (i.e. how many messages fit in)
 * the ring buffer. You can use the macros
 * PNR_RING_UNI_CAPACITY_TO_SHARED_SIZE() and
 * PNR_RING_UNI_SHARED_SIZE_TO_CAPACITY() to convert between a capacity and the
 * corresponding size in bytes, including at compile time.
 *
 * The actor responsible for initializing the shared structure does so with:
 * ~~~{.c}
 * myring_shared_init(pshared);
 * ~~~
 *
 * Each actor initializes its private structure. Producer:
 * ~~~{.c}
 * // The producer's private structure
 * myring_producer_t producer;
 *
 * // Initialize the producer's private structure
 * if (!myring_producer_init(&producer, pshared, shared_size)) {
 *   // shared_size is too small to hold a ring buffer; fail and exit
 *   ...
 * }
 * ~~~
 * Consumer:
 * ~~~{.c}
 * // The consumer's private structure
 * myring_consumer_t consumer;
 *
 * // Initialize the consumer's private structure
 * if (!myring_consumer_init(&consumer, pshared, shared_size)) {
 *   // shared_size is too small to hold a ring buffer; fail and exit
 *   ...
 * }
 * ~~~
 *
 * The producer and consumer must also register a handler for notifications. The
 * consumer should run its handler once after initialization to take care of any
 * notifications it may have missed before the handler was registered.
 *
 * When the producer wishes to produce messages or receives a notification from
 * the consumer, it shall repeatedly check out how much space is available for
 * production and then produce:
 * ~~~{.c}
 * while (we_have_something_to_produce && myring_producer_checkout(&producer)) {
 *   while (we_have_something_to_produce && myring_producer_free(&producer) > 0) {
 *     // Produce a message
 *     mymsg_t msg = ...;
 *     myring_producer_produce(&producer, &msg);
 *   }
 *   if (myring_producer_commit(&producer)) {
 *     // We have just produced messages and the consumer had requested to be notified; we must do so
 *     ...
 *   }
 * }
 * ~~~
 * Here, \c we_have_something_to_produce stands for an arbitrary condition that
 * means that the producer wishes to produce at least one message. The outer
 * loop calls \c myring_producer_checkout(), which checks whether there is some
 * space to produce a message in the ring and, if not, instructs the consumer to
 * send a notification to the producer when this changes. The inner loop
 * produces messages until either nothing remains to produce
 * (\c we_have_something_to_produce becomes false) or we reach the end of the
 * free space previously identified by \c myring_producer_checkout() (\c
 * myring_producer_free() returns 0). Each message is produced by
 * \c myring_producer_produce(), then the consumer is made aware of the
 * production by \c myring_producer_commit(). If that function returns \c true,
 * then we must send a notification to the consumer.
 *
 * When the consumer receives a notification from the producer, and also once
 * after initialization, it shall repeatedly check out how many messages are
 * waiting to be consumed, then consume them:
 * ~~~{.c}
 * while (myring_consumer_checkout(&consumer)) {
 *   mymsg_t msg;
 *   while (myring_consumer_consume(&consumer, &msg)) {
 *     // Deal with the message msg
 *     ...
 *   }
 *   if (myring_consumer_commit(&consumer)) {
 *     // We have just consumed messages and the producer had requested to be notified; we must do so
 *     ...
 *   }
 * }
 * ~~~
 * The outer loop calls \c myring_consumer_checkout(), which checks whether
 * there are unconsumed messages in the ring and, if not, instructs the producer
 * to send a notification to the consumer when this changes. The inner loop
 * consumes messages until we reach the end of the used space previously
 * identified by \c myring_consumer_checkout() (\c myring_consumer_consume()
 * returns \c false). Each message is consumed by \c myring_consumer_consume(),
 * then the producer is made aware of the consumption by
 * \c myring_consumer_commit(). If that function returns \c true, then we must
 * send a notification to the producer.
 *
 * Bidirectional ring buffers
 * --------------------------
 *
 * Both client and server must define the implementation of the ring buffer:
 * ~~~{.c}
 * // Our types of requests and responses
 * typedef ... myrequest_t;
 * typedef ... myresponse_t;
 *
 * // Generate the implementation of the ring buffer
 * PNR_RING_GENERATE_BI(myrequest_t, myresponse_t, myring)
 * ~~~
 *
 * Let us suppose that the actors have agreed to place the shared structure (of
 * type \c myring_shared_t) in a segment of shared memory of size \c shared_size
 * bytes. Each actor has a private suitably aligned pointer \c pshared to this
 * segment (the two pointers may live in different address spaces). The size of
 * the segment will determine the capacity of (i.e. how many messages fit in)
 * the ring buffer. You can use the macros PNR_RING_BI_CAPACITY_TO_SHARED_SIZE()
 * and PNR_RING_BI_SHARED_SIZE_TO_CAPACITY() to convert between a capacity and
 * the corresponding size in bytes, including at compile time.
 *
 * The actor responsible for initializing the shared structure does so with:
 * ~~~{.c}
 * myring_shared_init(pshared);
 * ~~~
 *
 * Each actor initializes its private structure. Client:
 * ~~~{.c}
 * // The client's private structure
 * myring_client_t client;
 *
 * // Initialize the client's private structure
 * if (!myring_client_init(&client, pshared, shared_size)) {
 *   // shared_size is too small to hold a ring buffer; fail and exit
 *   ...
 * }
 * ~~~
 * Server:
 * ~~~{.c}
 * // The server's private structure
 * myring_server_t server;
 *
 * // Initialize the server's private structure
 * if (!myring_server_init(&server, pshared, shared_size)) {
 *   // shared_size is too small to hold a ring buffer; fail and exit
 *   ...
 * }
 * ~~~
 *
 * The client and server must also register a handler for notifications. The
 * server should run its handler once after initialization to take care of any
 * notifications it may have missed before the handler was registered.
 *
 * When the client wishes to produce requests, it shall do so in a loop:
 * ~~~{.c}
 * void produce_requests(void) {
 *   while (we_have_something_to_produce && myring_client_free(&client) > 0) {
 *     // Produce a request
 *     myrequest_t req = ...;
 *     myring_client_produce(&client, &req);
 *   }
 *   if (myring_client_commit(&client)) {
 *     // We have just produced requests and the server had requested to be notified; we must do so
 *     ...
 *   }
 * }
 * ~~~
 * Here, \c we_have_something_to_produce stands for an arbitrary condition that
 * means that the client wishes to produce at least one request. The loop
 * produces requests until either nothing remains to produce
 * (\c we_have_something_to_produce becomes false) or we reach the end of the
 * space available for request production (\c myring_client_free() returns 0).
 * The requests are produced by \c myring_client_produce(), then the server is
 * made aware of the production by \c myring_client_commit(). If that function
 * returns \c true, then we must send a notification to the server.
 *
 * When the client receives a notification from the server, it shall repeatedly
 * check out how many responses are waiting to be consumed, then consume them.
 * Finally, it shall try sending requests, since it has just freed some space in
 * the ring:
 * ~~~{.c}
 * while (myring_client_checkout(&client)) {
 *   myresponse_t rsp;
 *   while (myring_client_consume(&client, &rsp)) {
 *     // Deal with the response rsp
 *     ...
 *   }
 * }
 * // Now that we have freed some space, let us try to produce more requests
 * produce_requests();
 * ~~~
 * The outer loop calls \c myring_client_checkout(), which checks whether there
 * are unconsumed responses in the ring and, if not, instructs the server to
 * send a notification to the client when this changes. The inner loop consumes
 * responses with \c myring_client_consume() until we reach the end of the
 * unconsumed space previously identified by \c myring_client_checkout()
 * (\c myring_client_consume() returns \c false). Finally, the client must not
 * forget to try sending more requests, which may now be possible thanks to the
 * space freed in the ring by consuming responses.
 *
 * When the server receives a notification from the client, and also once after
 * initialization, it shall repeatedly check out how many requests are waiting
 * to be consumed, then consume them:
 * ~~~{.c}
 * while (myring_server_checkout(&server)) {
 *   myrequest_t req;
 *   while (myring_server_consume(&server, &req)) {
 *     // Deal with the request req
 *     ...
 *   }
 * }
 * ~~~
 * The outer loop calls \c myring_server_checkout(), which checks whether there
 * are unconsumed requests in the ring and, if not, instructs the client to send
 * a notification to the server when this changes. The inner loop consumes
 * requests with \c myring_server_consume() until we reach the end of the
 * unconsumed space previously identified by \c myring_server_checkout()
 * (\c myring_server_consume() returns \c false).
 *
 * When the server wishes to produce responses, it shall do so in a loop:
 * ~~~{.c}
 * while (we_have_something_to_produce) {
 *   // Produce a response
 *   myresponse_t rsp = ...;
 *   assert(myring_server_produce(&server, &rsp));
 * }
 * if (myring_server_commit(&server)) {
 *   // We have just produced responses and the client had requested to be notified; we must do so
 *   ...
 * }
 * ~~~
 * Here, \c we_have_something_to_produce stands for an arbitrary condition that
 * means that the server wishes to produce at least one response. The loop
 * produces responses until nothing remains to produce
 * (\c we_have_something_to_produce becomes false). Each response is produced by
 * \c myring_server_produce(), then the client is made aware of the production
 * by \c myring_server_commit(). If that function returns \c true, then we must
 * send a notification to the client. Remark that unless the server violates the
 * requirement that there be exactly one response sent for each request, it can
 * be certain that there will be enough room in the ring to send all responses
 * (hence the assertion that \c myring_server_produce() always succeeds).
 *
 * Notifications
 * =============
 *
 * These generic ring buffers depend on, but do not include, a mechanism for
 * notifying the other party that they have something to do.
 *
 * Whenever the \c *_commit() functions return true, the caller is expected to
 * send a notification to the other end.
 *
 * Make sure the effects of your memory writes are visible when the other end
 * receives a notification. For instance, if notifications are implemented with
 * interrupts, perform a data synchronization barrier before you trigger the
 * interrupt.
 *
 * In order to minimize the need for notifications, the actors signal to each
 * other, through writes in shared memory, whether they need to be notified when
 * a certain event occurs. A consequence of this is that \c *_checkout() is
 * usually called in a loop. Each call determines whether the caller has work to
 * do. Until a call returns \c false, it is possible, but not guaranteed, that
 * no further notifications will be sent from the other end (because the caller
 * already knows that it has some work to do). When \c *_checkout() finally
 * returns false, the caller has made it clear to the other end that it needs
 * notifications to be sent again. This scheme allows uninterrupted
 * communications when traffic is high.
 *
 * Synchronization
 * ===============
 *
 * Users of the ring buffer library need not synchronize accesses by the two
 * actors (that is the whole point of using a ring buffer). However, actions
 * *within each actor* must be synchronized. In particular:
 * - The producer in a unidirectional ring buffer produces messages in two
 *   situations: when starting communication upon request from higher-level
 *   code, and when resuming production after it was stalled because the ring
 *   was full, upon receiving a notification from the consumer. Those two code
 *   paths must be serialized.
 * - Within the client or server of a bidirectional ring buffer, production and
 *   consumption must be serialized.
 *
 * Security {#security}
 * ========
 *
 * This implementation is designed to resist against attacks by a malicious
 * actor. In addition to correctly using the API, the user must take a few
 * precautions.
 *
 * The message/request/response types provided by the user must be robust for
 * use in a communication protocol with an untrusted actor. In particular,
 * padding bits must be absent.
 *
 * The shared structure shall reside in memory shared with the other party, but
 * the private structures shall not.
 *
 * After a call to \c *_peek*() has returned pointer(s) to slot(s) containing
 * messages/requests/responses to read, the caller can dereference these
 * pointers to directly read from the ring. Since these pointers point to shared
 * memory, make sure you validate the values and remember that the other party
 * could maliciously overwrite them at any time, including during or after
 * validation. A common idiom consists in first making a volatile copy of the
 * data to private memory, then validating the private copy. <b>Users are
 * strongly encouraged to use the \c *_consume() and \c *_consume_n() wrappers
 * that conveniently consume and make private copies</b>.
 *
 * Advanced usage
 * ==============
 *
 * Unidirectional ring buffers
 * ---------------------------
 *
 * The producer may use the \c *_producer_produce() function to copy a private
 * message to the ring buffer and record this production in one operation. If
 * the message type is quite large, it may be more efficient to build the
 * message in place in the ring buffer, instead of going through an intermediate
 * private message. To this end, the producer may first call the
 * \c *_producer_peek() function to get a pointer to the first free slot in the
 * ring (or \c NULL if there are no free slots), then write to this slot as it
 * sees fit, then register the production with a call to
 * \c *_producer_advance().
 *
 * The producer can produce several messages in one operation. The
 * \c *_producer_produce_n() function takes an array of private messages and
 * copies as many of them as possible to the ring buffer, and records this
 * production. Alternatively, it is possible to avoid going through a copy and
 * build all the messages in place in the ring buffer. First call
 * \c *_producer_peek_all() to get pointers to the free slots in the ring (in
 * the form of up to two consecutive ranges in memory, depending on whether or
 * not the free range wraps around the ring), then fill any prefix of this free
 * range, and finally call \c *_producer_advance_n() to record this production.
 *
 * Similar operations are available to the consumer: \c *_consumer_peek(),
 * \c *_consumer_advance(), \c *_consumer_consume_n(), \c *_consumer_peek_all(),
 * and \c *_consumer_advance_n(). They make it possible to consume several
 * messages simultaneouly and/or without going through a copy in shared memory.
 *
 * **Directly accessing shared memory without going through a volatile copy, in
 * particular for the consumer, has [security implications](@ref security).**
 *
 * Bidirectional ring buffers
 * --------------------------
 *
 * The client may use the \c *_client_produce() function to copy a private
 * request to the ring buffer and record this production in one operation. If
 * the request type is quite large, it may be more efficient to build the
 * request in place in the ring buffer, instead of going through an intermediate
 * private request. To this end, the client may first call the
 * \c *_client_peek_prod() function to get a pointer to the first free request
 * slot in the ring (or \c NULL if there are no free slots), then write to this
 * slot as it sees fit, then register the production with a call to
 * \c *_client_advance_prod(). Similarly, instead of consuming a response by
 * going through a private copy with \c *_client_consume(), the client may use
 * \c *_client_peek_cons(), read the response in place, then call
 * \c *_client_advance_cons().
 *
 * Similar operations are available to the server: \c *_server_peek_prod(),
 * \c *_server_advance_prod(), \c *_server_peek_cons(), and
 * \c *_server_advance_cons().
 *
 * **Directly accessing shared memory without going through a volatile copy, in
 * particular for consuming, has [security implications](@ref security).**
 */

/*
 * Implementation details
 * ======================
 *
 * Unidirectional ring buffers
 * ---------------------------
 *
 * Consider an infinite array and infinite integers. In this array, the producer
 * produces messages, and the consumer consumes them. The producer and consumer
 * maintain producer and consumer indices that point to the next slot in which
 * to produce or consume:
 *
 * ~~~
 * ┌──────┬──────────┬┄
 * │ Free │ Messages │ Free
 * └──────┴──────────┴┄
 *         ^          ^
 *         c          p
 *
 * c: consumer's index
 * p: producer's index
 * ~~~
 *
 * In normal operation, c ≤ p. The range of the array that is in use is [c, p),
 * and it slides to the right.
 *
 * If we impose the additional constraint that p - c ≤ some constant CAPACITY,
 * then we can implement this structure in a finite array of length CAPACITY,
 * and map an index i to the element at array index i % CAPACITY.
 *
 * In addition, since the indices never differ by more than CAPACITY, we can
 * implement them with finite unsigned integers (with arithmetic modulo 2^w for
 * some w). We do not need to test for overflows as long as index differences
 * are concerned; however, for i % CAPACITY to remain unchanged, we need
 * CAPACITY to be a divisor of 2^w. Also, notice that we need to represent all
 * index differences in [0, CAPACITY] (both bounds included, then), which
 * implies that CAPACITY < 2^w. CAPACITY must therefore be of the form 2^p with
 * p < w. All operations i % CAPACITY can then be optimized as i & (CAPACITY -
 * 1).
 *
 * The producer and consumer share p and c. The producer (resp. consumer) is
 * responsible for updating p (resp. c) from time to time, to make its
 * production (resp. consumption) visible to the consumer (resp. producer). In
 * our implementation, both producer and consumer also maintain private versions
 * of p and c, and use them to track the unconsumed messages.
 *
 * The producer knows it can produce messages until p == c + CAPACITY. The
 * consumer knows it can consume messages until c == p.
 *
 * The producer maintains in its private \c *_producer_t structure:
 * - the producer index \c prod;
 * - the last value \c last_published_prod of the producer index that was copied
 * to the shared structure;
 * - a bound \c prod_end, which is computed when the producer checks out the
 * state of the ring, and is such that we can produce until prod == prod_end.
 *
 * The consumer maintains in its private \c *_consumer_t structure:
 * - the consumer index \c cons;
 * - the last value \c last_published_cons of the consumer index that was copied
 * to the shared structure;
 * - a bound \c cons_end, which is computed when the consumer checks out the
 * state of the ring, and is such that we can consumer until cons == cons_end.
 *
 * prod (resp. cons) is kept private while we produce (resp. consume), and it is
 * copied to the \c *_shared_t structure shared with the other party when we
 * "commit" this production (resp. consumption).
 *
 * The initialization of prod_end (resp. cons_end) is subtle. With the
 * explanations above, the reader would expect prod_end (resp. cons_end) to be
 * initialized to c + CAPACITY (resp. p).
 *
 * However, we try to protect ourselves from the other party in case it
 * publishes a bogus index. We detect that something is wrong when the other
 * party pretends it has consumed (resp. produced) in a zone that oversteps in
 * the zone where we are supposed to produce (resp. consume). In that case, we
 * do not change the value of prod_end (resp. cons_end) until the other party
 * comes to its senses.
 *
 * The shared structure \c *_shared_t consists of:
 * - The producer and consumer indices \c prod and \c cons published by the
 *   producer and consumer, implemented as atomic integers.
 * - Two atomic integers \c prod_limit and \c cons_limit such that, if a commit
 *   makes \c prod (resp. \c cons) pass strictly beyond \c prod_limit (resp.
 *   \c cons_limit), then a notification must be sent.
 * - The array \c array of slots, each of which can contain a message.
 *
 * Bidirectional ring buffers
 * --------------------------
 *
 * As in the unidirectional ring buffer, let us start with an infinite array. In
 * this array, the client produces requests, the server consumes them and
 * eventually replaces them with responses, that the client consumes in turn.
 * The client and server maintain producer and consumer indices that point to
 * the next slot in which to produce or consume:
 *
 * ~~~
 * ┌──────┬───────────┬──────┬──────────┬┄
 * │ Free │ Responses │ Free │ Requests │ Free
 * └──────┴───────────┴──────┴──────────┴┄
 *         ^           ^      ^          ^
 *         cc          sp     sc         cp
 *
 * cc: client's consumer index
 * sp: server's producer index
 * sc: server's consumer index
 * cp: client's producer index
 * ~~~
 *
 * In normal operation, cc ≤ sp ≤ sc ≤ cp. The range of the array that is in use
 * is [cc, cp), and it slides to the right.
 *
 * If we impose the additional constraint that cp - cc ≤ CAPACITY, then we can
 * implement this structure in a finite array of length CAPACITY, and map an
 * index i to the element at array index i % CAPACITY, as before. For the same
 * reasons, CAPACITY is of the form 2^p with p < w.
 *
 * The client and server only need to share their producer indices. In our
 * implementation, they actually maintain private producer indices, which they
 * copy from time to time to a shared structure to make their productions
 * visible to each other.
 *
 * The client internally maintains cc to track the unconsumed responses. It
 * knows it can consume responses until cc == sp. It knows it can produce
 * requests until cp == cc + CAPACITY.
 *
 * The server internally maintains sc to track the unconsumed requests. It knows
 * it can consume requests until sc == cp. It knows it can produce responses
 * until sp == sc.
 *
 * We can see that the producing condition for the server is simpler. This is
 * because, for the server, the consuming range is ahead of the producing range,
 * while the client has to wrap around. For this reason, we artificially move
 * the client's consuming indices CAPACITY elements ahead: cc' = cc + CAPACITY.
 * In our code, the client and server each maintain private indices in their
 * \c *_private_t structures:
 * - the consumer index \c cons, which represents cc' for the client and sc for
 * the server;
 * - a bound \c cons_end, which is computed when the client or server checks out
 * the state of the ring, and is such that we can consume until cons ==
 * cons_end;
 * - the producer index \c prod, which represents cp for the client and sp for
 * the server; We can produce until prod == cons;
 * - the last value \c last_published_prod of the producer index that was copied
 * to the shared structure.
 *
 * prod is kept private while we produce, and it is copied to the \c *_shared_t
 * structure shared with the other party when we "commit" this production.
 *
 * The initialization of cons_end is subtle. With the explanations above, the
 * reader would expect cons_end to be initialized to:
 * - for the client: sp + CAPACITY (remember, cons is cc');
 * - for the server: cp.
 *
 * However, we try to protect ourselves from the other party in case it
 * publishes a bogus producer index. We detect that something is wrong when the
 * other party pretends it has produced in a zone that oversteps in the zone
 * where we are supposed to produce. In that case, we do not change the value of
 * cons_end, thus refusing to consume anything until the other party comes to
 * its senses.
 *
 * The shared structure \c *_shared_t consists of:
 * - The producer indices \c cprod and \c sprod published by the client and
 *   server, implemented as atomic integers.
 * - Two atomic integers \c cprod_limit and \c sprod_limit such that, if a
 *   commit makes \c cprod (resp. \c sprod) pass strictly beyond \c cprod_limit
 *   (resp. \c sprod_limit), then a notification must be sent.
 * - The array \c array of slots, each of which can contain a request or a
 *   response.
 *
 * Security
 * --------
 *
 * Padding and trap representations
 *
 * This library defines types (indices, structures and unions) living in shared
 * memory. Because padding bits take unspecified values and may leak
 * information, we make sure to eliminate all padding bits.
 *
 * Our pnr_ring_index_t type is defined as an unsigned integer type with no
 * padding bits and no trap representations, making it safe to load and store.
 *
 * Moreover, for each structure or union that we define, we eliminate padding
 * by:
 * 1. defining a first type, without worrying about padding (the "unsafe
 *    blueprint");
 * 2. then, defining the actual type as a copy of the unsafe blueprint, but with
 *    all padding bytes replaced with explicit arrays of unsigned chars. The
 *    amount of padding is computed by the PNR_RING_PAD_* macros using the
 *    sizeof operator and offsetof macro.
 *
 * TOC/TOU
 *
 * We provide "safe" consuming functions that peek whether an unconsumed
 * message/request/response is available, and if so, make a private copy of the
 * first one and consume it. This encourages the user to validate and then use
 * the private rather than the shared copy, and therefore thwart TOC/TOU attacks
 * by a malicious party that would overwrite the shared copy between validation
 * and use. For this precaution to be effective, we must make sure that the C
 * compiler will not decide to re-read the shared copy. To understand the issue,
 * consider a seemingly reasonable implementation:
 *
 * static inline _Bool my_ring_client_consume(my_ring_client_t *client,
 *   my_rsp_t *private_rsp) {
 *   my_rsp_t *shared_rsp = my_ring_client_peek_cons(client);
 *   if (shared_rsp == 0)
 *     return 0;
 *   *private_rsp = *shared_rsp;
 *   my_ring_client_advance(client);
 *   return 1;
 * }
 *
 * The user would subsequently validate and then use *private_rsp. But what if a
 * smart compiler decides that subsequent reads of *private_rsp can be replaced
 * by equivalent reads of *shared_rsp, since the two values are equal, thus
 * making our code vulnerable to attacks? The C standard currently has no notion
 * of memory shared with an untrusted party; all it knows about are threads,
 * which collaborate to avoid data races. It can be argued that such a compiler
 * would not violate the standard, for the following reason. The C11 standard
 * specifies that data races (i.e. two or more concurrent accesses to the same
 * non-atomic object, at least one of which is a write) have undefined behavior,
 * and free the compiler from its obligations. Assume that my_rsp_t is not an
 * atomic type, and that there is no synchronization primitive in the program
 * between the copy C of *shared_rsp to *private_rsp and a subsequent read R of
 * a part of *private_rsp. If replacing R with an equivalent read R' of
 * *shared_rsp changes the behavior of the program, then it means that another
 * thread T has been concurrently writing to the part of *shared_rsp read by R'
 * since we performed C. But then, the absence of synchronization primitives
 * means that a possible behavior would be that T run faster and modify
 * *shared_rsp while the main thread execute C, which would trigger undefined
 * behavior since my_rsp_t is not atomic. In summary, replacing R with R' would
 * preserve the behavior of the program, unless said behavior was undefined,
 * which makes such a change acceptable for C11.
 *
 * We must work around C11 here. What we can do is make the read volatile in the
 * copy C. Then the compiler will be prevented from assuming that *private_rsp
 * and *shared_rsp remain equal in the absence of synchronization before R. Keep
 * in mind that volatile is here for security reasons (to protect ourselves
 * against TOC/TOU attacks), not for synchronization (for which it is useless).
 */

// We need the standard types from <stdint.h> but Linux redefines them
#ifdef __KERNEL__
#include <linux/string.h>
#include <linux/types.h>
#ifndef UINT32_C
#define UINT32_C(c) c ## U
#endif
#ifndef UINT32_MAX
#define UINT32_MAX 0xffffffffU
#endif
#else
#include <stdint.h>
#include <string.h>
#endif

#include <stdatomic.h>
#include <stddef.h>

/// The type of an index in a ring buffer
typedef uint32_t pnr_ring_index_t;

/*
 * Internal definitions; implementation details that the user need not care
 * about
 */

/// @cond INTERNAL

/**
 * @brief Expands to the declaration of a padding array that fits after a union
 * member.
 * @param type the union type
 * @param mem the name of the member
 */
#define PNR_RING_PAD_UMEM(type, mem)                                           \
  unsigned char mem##_pad[sizeof(type) - sizeof ((type *)0)->mem];

/**
 * @brief Expands to the declaration of a padding array that fits between two
 * consecutive members of a structure.
 * @param type the structure type
 * @param mem1 the name of the first member
 * @param mem2 the name of the second member
 */
#define PNR_RING_PAD_2MEM(type, mem1, mem2)                                    \
  unsigned char mem1##_pad[offsetof(type, mem2) - offsetof(type, mem1) -       \
  sizeof ((type *)0)->mem1];

/**
 * @brief Performs a memory barrier preventing stores before it to be reordered
 * with loads after it. This kind of heavy barrier is absent from C11.
 */
static inline void pnr_ring_store_load_fence(void) {
#if defined(__KERNEL__)
  // In the Linux kernel, use the virt_mb abstraction (so that all the
  // architectures are supported)
  virt_mb();
#elif defined(__arm__) || defined(__aarch64__)
  __asm__ volatile("dmb ish" ::: "memory");
#elif defined(__x86_64__)
  __asm__ volatile("mfence" ::: "memory");
#else
  #error "Missing definition of pnr_ring_store_load_fence on this architecture"
#endif
}

/**
 * @brief A convenience macro which rounds down a 32 bit unsigned integer less
 * than 2^2 to the largest power of 2 less than or equal to it.
 * @param x the value to round down
 * @return the largest 32-bit power of 2 less than or equal to \p x, if any
 * exists, and 0 otherwise; it is a compile-time constant if \p x is
 */
#define PNR_RING_ROUND_DOWN_POWER2_2(x)                                        \
  ((x) / UINT32_C(2) == 0 ? (x) : UINT32_C(2))

/**
 * @brief A convenience macro which rounds down a 32 bit unsigned integer less
 * than 2^4 to the largest power of 2 less than or equal to it.
 * @param x the value to round down
 * @return the largest 32-bit power of 2 less than or equal to \p x, if any
 * exists, and 0 otherwise; it is a compile-time constant if \p x is
 */
#define PNR_RING_ROUND_DOWN_POWER2_4(x)                                        \
  ((x) / UINT32_C(4) == 0 ?                                                    \
  PNR_RING_ROUND_DOWN_POWER2_2(x) :                                            \
  PNR_RING_ROUND_DOWN_POWER2_2((x) / UINT32_C(4)) * UINT32_C(4))

/**
 * @brief A convenience macro which rounds down a 32 bit unsigned integer less
 * than 2^8 to the largest power of 2 less than or equal to it.
 * @param x the value to round down
 * @return the largest 32-bit power of 2 less than or equal to \p x, if any
 * exists, and 0 otherwise; it is a compile-time constant if \p x is
 */
#define PNR_RING_ROUND_DOWN_POWER2_8(x)                                        \
  ((x) / UINT32_C(0x10) == 0 ?                                                 \
  PNR_RING_ROUND_DOWN_POWER2_4(x) :                                            \
  PNR_RING_ROUND_DOWN_POWER2_4((x) / UINT32_C(0x10)) * UINT32_C(0x10))

/**
 * @brief A convenience macro which rounds down a 32 bit unsigned integer less
 * than 2^16 to the largest power of 2 less than or equal to it.
 * @param x the value to round down
 * @return the largest 32-bit power of 2 less than or equal to \p x, if any
 * exists, and 0 otherwise; it is a compile-time constant if \p x is
 */
#define PNR_RING_ROUND_DOWN_POWER2_16(x)                                       \
  ((x) / UINT32_C(0x100) == 0 ?                                                \
  PNR_RING_ROUND_DOWN_POWER2_8(x) :                                            \
  PNR_RING_ROUND_DOWN_POWER2_8((x) / UINT32_C(0x100)) * UINT32_C(0x100))

/**
 * @brief A convenience macro which rounds down a 32 bit unsigned integer to the
 * largest power of 2 less than or equal to it.
 * @param x the value to round down
 * @return the largest 32-bit power of 2 less than or equal to \p x, if any
 * exists, and 0 otherwise; it is a compile-time constant if \p x is
 */
#define PNR_RING_ROUND_DOWN_POWER2_32(x)                                       \
  ((x) / UINT32_C(0x10000) == 0 ?                                              \
  PNR_RING_ROUND_DOWN_POWER2_16(x) :                                           \
  PNR_RING_ROUND_DOWN_POWER2_16((x) / UINT32_C(0x10000)) * UINT32_C(0x10000))

/**
 * @brief Represents a logical range of message slots in an untyped ring. It
 * consists of two physical contiguous subranges.
 *
 * If the logical range is empty, so are the two physical subranges.
 *
 * If the logical range does not wrap around the ring buffer, it is represented
 * by the first physical subrange, and the second subrange is empty.
 *
 * If the logical range wraps around the ring buffer, the two physical subranges
 * are used.
 */
typedef struct pnr_ring_range {
  /** A pointer to the first physical subrange */
  void *fst_begin;
  /** The number of slots in the first physical range. 0 if empty */
  pnr_ring_index_t fst_count;
  /** A pointer to the second physical subrange */
  void *snd_begin;
  /** The number of slots in the second physical range. 0 if empty */
  pnr_ring_index_t snd_count;
} pnr_ring_range_t;

/**
 * @brief Converts a logical range of message slots in a ring buffer to a pair
 * of physical ranges.
 * @param msg_size the size of messages, in bytes
 * @param ring_msgs the ring's array of message slots
 * @param ring_capacity the length of the ring's array of message slots, which
 * must be a power of 2
 * @param ring_begin the unmasked begin index of the logical range
 * @param ring_end the unmasked past-the-end index of the logical range
 * @return the translated range
 */
static inline pnr_ring_range_t pnr_ring_ranges(size_t msg_size, void *ring_msgs,
  pnr_ring_index_t ring_capacity, pnr_ring_index_t ring_begin,
  pnr_ring_index_t ring_end) {
  pnr_ring_index_t masked_ring_begin, rem, count;
  pnr_ring_range_t range;
  masked_ring_begin = ring_begin & (ring_capacity - 1);
  range.fst_begin = (unsigned char *)ring_msgs + masked_ring_begin * msg_size;
  range.snd_begin = ring_msgs;
  rem = ring_capacity - masked_ring_begin;
  count = ring_end - ring_begin;
  if (count <= rem) {
    range.fst_count = count;
    range.snd_count = 0;
  }
  else {
    range.fst_count = rem;
    range.snd_count = count - rem;
  }
  return range;
}

/**
 * @brief A low-level function that copies a range of messages from an untyped
 * ring, possibly splitting the copy in two if the ring wraps around.
 * @param msg_size the size of messages, in bytes
 * @param priv_msgs the target messages
 * @param priv_count the number of target messages
 * @param ring_msgs the ring's array of message slots
 * @param ring_capacity the length of the ring's array of message slots, which
 * must be a power of 2
 * @param ring_begin the unmasked begin index of the ring's range
 * @param ring_end the unmasked past-the-end index of the ring's range
 * @return the number of messages copied from the ring
 */
static inline pnr_ring_index_t pnr_ring_copy_from_ring(size_t msg_size,
  void *priv_msgs, pnr_ring_index_t priv_count, void const *ring_msgs,
  pnr_ring_index_t ring_capacity, pnr_ring_index_t ring_begin,
  pnr_ring_index_t ring_end) {
  pnr_ring_index_t ring_count, masked_ring_begin, rem;
  ring_count = ring_end - ring_begin;
  if (priv_count > ring_count)
    priv_count = ring_count;
  masked_ring_begin = ring_begin & (ring_capacity - 1);
  rem = ring_capacity - masked_ring_begin;
  if (priv_count <= rem)
    memcpy(priv_msgs, (unsigned char const *)ring_msgs +
      masked_ring_begin * msg_size, priv_count * msg_size);
  else {
    memcpy(priv_msgs, (unsigned char const *)ring_msgs +
      masked_ring_begin * msg_size, rem * msg_size);
    memcpy((unsigned char *)priv_msgs + rem * msg_size, ring_msgs,
      (priv_count - rem) * msg_size);
  }
  return priv_count;
}

/**
 * @brief A low-level function that copies a range of messages to an untyped
 * ring, possibly splitting the copy in two if the ring wraps around.
 * @param msg_size the size of messages, in bytes
 * @param ring_msgs the ring's array of message slots
 * @param ring_capacity the length of the ring's array of message slots, which
 * must be a power of 2
 * @param ring_begin the unmasked begin index of the ring's range
 * @param ring_end the unmasked past-the-end index of the ring's range
 * @param priv_msgs the source messages
 * @param priv_count the number of source messages
 * @return the number of messages copied to the ring
 */
static inline pnr_ring_index_t pnr_ring_copy_to_ring(size_t msg_size,
  void *ring_msgs, pnr_ring_index_t ring_capacity, pnr_ring_index_t ring_begin,
  pnr_ring_index_t ring_end, void const *priv_msgs,
  pnr_ring_index_t priv_count) {
  pnr_ring_index_t ring_count, masked_ring_begin, rem;
  ring_count = ring_end - ring_begin;
  if (priv_count > ring_count)
    priv_count = ring_count;
  masked_ring_begin = ring_begin & (ring_capacity - 1);
  rem = ring_capacity - masked_ring_begin;
  if (priv_count <= rem)
    memcpy((unsigned char *)ring_msgs + masked_ring_begin * msg_size, priv_msgs,
      priv_count * msg_size);
  else {
    memcpy((unsigned char *)ring_msgs + masked_ring_begin * msg_size, priv_msgs,
      rem * msg_size);
    memcpy(ring_msgs, (unsigned char const *)priv_msgs + rem * msg_size,
      (priv_count - rem) * msg_size);
  }
  return priv_count;
}

/// @endcond

/*
 * API
 */

/**
 * @brief A convenience macro which rounds down an unsigned integer to the
 * largest power of 2 less than or equal to it that also fits in a
 * pnr_ring_index_t.
 * @param x the value to round down
 * @return the largest pnr_ring_index_t which is a power of 2 less than or equal
 * to \p x, if any exists, and 0 otherwise
 */
#define PNR_RING_ROUND_DOWN_POWER2_INDEX(x)                                    \
  PNR_RING_ROUND_DOWN_POWER2_32((x) > UINT32_MAX ? UINT32_MAX : (uint32_t)(x))

/*
 * Unidirectional ring buffers
 */

/**
 * @brief Generates the implementation of a type of unidirectional ring buffer.
 * @param msg_t the type of messages
 * @param prefix a prefix for the various identifiers
 */
#define PNR_RING_GENERATE_UNI(msg_t, prefix)                                   \
                                                                               \
/*                                                                             \
 * @brief An alias for the type of messages; useful for macro-generated uses.  \
 */                                                                            \
typedef msg_t prefix##_message_t;                                              \
                                                                               \
/*                                                                             \
 * @brief Represents a logical range of message slots in the ring. It consists \
 * of two physical contiguous subranges.                                       \
 *                                                                             \
 * If the logical range is empty, so are the two physical subranges.           \
 *                                                                             \
 * If the logical range does not wrap around the ring buffer, it is            \
 * represented by the first physical subrange, and the second subrange is      \
 * empty.                                                                      \
 *                                                                             \
 * If the logical range wraps around the ring buffer, the two physical         \
 * subranges are used.                                                         \
 */                                                                            \
typedef struct prefix##_range {                                                \
  /* A pointer to the first physical subrange */                               \
  msg_t *fst_begin;                                                            \
  /* The number of slots in the first physical range. 0 if empty */            \
  pnr_ring_index_t fst_count;                                                  \
  /* A pointer to the second physical subrange */                              \
  msg_t *snd_begin;                                                            \
  /* The number of slots in the second physical range. 0 if empty */           \
  pnr_ring_index_t snd_count;                                                  \
} prefix##_range_t;                                                            \
                                                                               \
/*                                                                             \
 * @brief The unsafe blueprint for prefix##_shared_t.                          \
 */                                                                            \
typedef struct {                                                               \
  /* The index of the next slot in which the producer will write */            \
  pnr_ring_index_t _Atomic prod;                                               \
  /* When cons strictly passes this value, the consumer shall notify the       \
     producer */                                                               \
  pnr_ring_index_t _Atomic cons_limit;                                         \
  /* The index of the next slot from which the consumer will read */           \
  pnr_ring_index_t _Atomic cons;                                               \
  /* When prod strictly passes this value, the producer shall notify the       \
    consumer */                                                                \
  pnr_ring_index_t _Atomic prod_limit;                                         \
  /* The message slots */                                                      \
  msg_t array[];                                                               \
} prefix##_unsafe_shared_t;                                                    \
                                                                               \
/*                                                                             \
 * @brief The shared structure of the ring.                                    \
 */                                                                            \
typedef struct prefix##_shared {                                               \
  /* The index of the next slot in which the producer will write */            \
  pnr_ring_index_t _Atomic prod;                                               \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, prod, cons_limit)                \
  /* When cons strictly passes this value, the consumer shall notify the       \
     producer */                                                               \
  pnr_ring_index_t _Atomic cons_limit;                                         \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, cons_limit, cons)                \
  /* The index of the next slot from which the consumer will read */           \
  pnr_ring_index_t _Atomic cons;                                               \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, cons, prod_limit)                \
  /* When prod strictly passes this value, the producer shall notify the       \
    consumer */                                                                \
  pnr_ring_index_t _Atomic prod_limit;                                         \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, prod_limit, array)               \
  /* The message slots */                                                      \
  msg_t array[];                                                               \
} prefix##_shared_t;                                                           \
                                                                               \
/* Check that all padding was accounted for */                                 \
_Static_assert(offsetof(prefix##_unsafe_shared_t, array) ==                    \
  offsetof(prefix##_shared_t, array), "");                                     \
                                                                               \
/*                                                                             \
 * @brief The structure private to the producer.                               \
 */                                                                            \
typedef struct prefix##_producer {                                             \
  /* The capacity of the ring */                                               \
  pnr_ring_index_t capacity;                                                   \
  /*                                                                           \
   * The index of the next slot to write; it will be copied to the shared      \
   * structure when we commit                                                  \
   */                                                                          \
  pnr_ring_index_t prod;                                                       \
  /* The most recent value of prod that was copied to the shared structure */  \
  pnr_ring_index_t last_published_prod;                                        \
  /* An index such that we may produce until prod == prod_end */               \
  pnr_ring_index_t prod_end;                                                   \
  /* A pointer to the shared structure */                                      \
  prefix##_shared_t *shared;                                                   \
} prefix##_producer_t;                                                         \
                                                                               \
/*                                                                             \
 * @brief The structure private to the consumer.                               \
 */                                                                            \
typedef struct prefix##_consumer {                                             \
  /* The capacity of the ring */                                               \
  pnr_ring_index_t capacity;                                                   \
  /*                                                                           \
   * The index of the next slot to read; it will be copied to the shared       \
   * structure when we commit                                                  \
   */                                                                          \
  pnr_ring_index_t cons;                                                       \
  /* The most recent value of cons that was copied to the shared structure */  \
  pnr_ring_index_t last_published_cons;                                        \
  /* An index such that we may consume until cons == cons_end */               \
  pnr_ring_index_t cons_end;                                                   \
  /* A pointer to the shared structure */                                      \
  prefix##_shared_t *shared;                                                   \
} prefix##_consumer_t;                                                         \
                                                                               \
/*                                                                             \
 * @brief Producer only. Initializes the producer structure. The shared        \
 * structure must be initialized (either by the producer or consumer) before   \
 * any other function is called.                                               \
 * @param producer a pointer to the producer's private structure               \
 * @param shared a pointer to the shared structure                             \
 * @param size the size in bytes that the shared structure can use             \
 * @return whether initialization succeeds; it only fails if \p size is too    \
 * small for a shared structure with at least one slot                         \
 */                                                                            \
static inline _Bool prefix##_producer_init(prefix##_producer_t *producer,      \
  prefix##_shared_t *shared, size_t size) {                                    \
  pnr_ring_index_t capacity =                                                  \
    PNR_RING_UNI_SHARED_SIZE_TO_CAPACITY(prefix, size);                        \
  producer->capacity = capacity;                                               \
  producer->prod = 0;                                                          \
  producer->last_published_prod = 0;                                           \
  producer->prod_end = capacity;                                               \
  producer->shared = shared;                                                   \
  return capacity != 0;                                                        \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Retrieves the capacity of the ring buffer.            \
 * @param producer a pointer to the producer's private structure               \
 * @return the capacity of the ring buffer                                     \
 */                                                                            \
static inline pnr_ring_index_t prefix##_producer_capacity(                     \
  prefix##_producer_t *producer) {                                             \
  return producer->capacity;                                                   \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Internal helper function. Producer only. Checks out the available    \
 * production space in the ring buffer and updates the private state           \
 * accordingly.                                                                \
 * @param producer a pointer to the producer's private structure               \
 * @return whether the ring is not full                                        \
 */                                                                            \
static inline _Bool prefix##_producer_checkout_helper(                         \
  prefix##_producer_t *producer) {                                             \
  pnr_ring_index_t prod, capacity, cons;                                       \
  prod = producer->prod;                                                       \
  capacity = producer->capacity;                                               \
  cons = atomic_load_explicit(&producer->shared->cons, memory_order_acquire);  \
  /* We can produce until we reach cons + capacity. Let us make sure that this \
     is not more than capacity slots away, i.e. that the consumer does not     \
     pretend that it has consumed beyond the private producer index. Note that \
     it is actually not supposed to consume beyond the last *published*        \
     producer index, but this stricter check would cost a second comparison */ \
  if ((pnr_ring_index_t)(prod - cons) <= capacity)                             \
    producer->prod_end = cons + capacity;                                      \
  return producer->prod_end != prod;                                           \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Checks out the available production space in the ring \
 * buffer and updates the private state accordingly. If the ring is full, asks \
 * for a notification from the consumer.                                       \
 * @param producer a pointer to the producer's private structure               \
 * @return whether the ring is not full                                        \
 */                                                                            \
static inline _Bool prefix##_producer_checkout(                                \
  prefix##_producer_t *producer) {                                             \
  if (prefix##_producer_checkout_helper(producer))                             \
    /* There is some room to produce something */                              \
    return 1;                                                                  \
  /* The ring is full; let the consumer know that it needs to notify us when   \
     this changes */                                                           \
  atomic_store_explicit(&producer->shared->cons_limit, producer->prod_end -    \
    producer->capacity, memory_order_relaxed);                                 \
  /* Make sure that the next checkout is not reordered before the store to     \
     cons_limit */                                                             \
  pnr_ring_store_load_fence();                                                 \
  /* Check out again, in case the consumer freed some space between our last   \
     checkout and the moment we asked for a notification */                    \
  return prefix##_producer_checkout_helper(producer);                          \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Retrieves the number of free slots in the ring        \
 * buffer.                                                                     \
 * @param producer a pointer to the producer's private structure               \
 * @return the number of free slots                                            \
 */                                                                            \
static inline pnr_ring_index_t prefix##_producer_free(                         \
  prefix##_producer_t *producer) {                                             \
  return producer->prod_end - producer->prod;                                  \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Returns a pointer to the first free slot in which to  \
 * write a message. This is a low-level function; consider using               \
 * *_producer_produce() instead.                                               \
 *                                                                             \
 * If there is room for a new message, then a pointer to the first free slot   \
 * is returned. The producer is then expected to write the message, then call  \
 * *_producer_advance().                                                       \
 *                                                                             \
 * If there is no room for a new message, then \c NULL is returned.            \
 * @param producer a pointer to the producer's private structure               \
 * @return a pointer to the first free slot, or \c NULL if the ring is full    \
 */                                                                            \
static inline msg_t *prefix##_producer_peek(prefix##_producer_t *producer) {   \
  pnr_ring_index_t prod = producer->prod;                                      \
  return prod == producer->prod_end ? 0 :                                      \
    &producer->shared->array[prod & (producer->capacity - 1)];                 \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Returns the range of free slots in which to write     \
 * messages. This is a low-level function; consider using                      \
 * *_producer_produce_n() instead.                                             \
 *                                                                             \
 * The producer is then expected to write messages at the beginning of the     \
 * returned range, then call *_producer_advance_n().                           \
 * @param producer a pointer to the producer's private structure               \
 * @return the free range                                                      \
 */                                                                            \
static inline prefix##_range_t prefix##_producer_peek_all(                     \
  prefix##_producer_t *producer) {                                             \
  pnr_ring_range_t untyped_range;                                              \
  prefix##_range_t typed_range;                                                \
  untyped_range = pnr_ring_ranges(sizeof(msg_t), producer->shared->array,      \
    producer->capacity, producer->prod, producer->prod_end);                   \
  typed_range.fst_begin = untyped_range.fst_begin;                             \
  typed_range.fst_count = untyped_range.fst_count;                             \
  typed_range.snd_begin = untyped_range.snd_begin;                             \
  typed_range.snd_count = untyped_range.snd_count;                             \
  return typed_range;                                                          \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Registers that a message was produced in the slot     \
 * returned by a previous call to *_producer_peek(). This is a low-level       \
 * function; consider using *_producer_produce() instead.                      \
 *                                                                             \
 * The producer is expected to call *_producer_commit() at some point to make  \
 * that production visible to the consumer.                                    \
 * @param producer a pointer to the producer's private structure               \
 */                                                                            \
static inline void prefix##_producer_advance(prefix##_producer_t *producer) {  \
  ++producer->prod;                                                            \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Registers that messages were produced in the first    \
 * \p count slots returned by a previous call to *_producer_peek_all().        \
 * This is a low-level function; consider using *_producer_produce_n()         \
 * instead.                                                                    \
 *                                                                             \
 * The producer is expected to call *_producer_commit() at some point to make  \
 * that production visible to the consumer.                                    \
 * @param producer a pointer to the producer's private structure               \
 */                                                                            \
static inline void prefix##_producer_advance_n(                                \
  prefix##_producer_t *producer, pnr_ring_index_t count) {                     \
  producer->prod += count;                                                     \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Produces a message.                                   \
 *                                                                             \
 * If there are no free slots in the ring, returns \c false. Otherwise, copies \
 * \c *\p msg to the ring, then returns \c true.                               \
 *                                                                             \
 * The producer is expected to call *_producer_commit() at some point to make  \
 * that production visible to the consumer.                                    \
 * @param producer a pointer to the producer's private structure               \
 * @param msg a pointer to the private message to copy                         \
 * @return whether a message was produced                                      \
 */                                                                            \
static inline _Bool prefix##_producer_produce(                                 \
  prefix##_producer_t *producer, msg_t const *msg) {                           \
  pnr_ring_index_t prod = producer->prod;                                      \
  if (prod == producer->prod_end)                                              \
    return 0;                                                                  \
  producer->shared->array[prod & (producer->capacity - 1)] = *msg;             \
  producer->prod = prod + 1;                                                   \
  return 1;                                                                    \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Produces messages.                                    \
 *                                                                             \
 * Copies the messages from the array \p msgs to the ring until \p count       \
 * messages have been copied or the ring is full.                              \
 *                                                                             \
 * The producer is expected to call *_producer_commit() at some point to make  \
 * that production visible to the consumer.                                    \
 * @param producer a pointer to the producer's private structure               \
 * @param msgs a pointer to the array of private messages to copy              \
 * @return the number of messages that were produced                           \
 */                                                                            \
static inline pnr_ring_index_t prefix##_producer_produce_n(                    \
  prefix##_producer_t *producer, msg_t const *msgs, pnr_ring_index_t count) {  \
  return pnr_ring_copy_to_ring(sizeof(msg_t), producer->shared->array,         \
    producer->capacity, producer->prod, producer->prod_end, msgs, count);      \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Producer only. Makes all of the production so far visible to the     \
 * consumer.                                                                   \
 * @param producer a pointer to the producer's private structure               \
 * @return whether a notification shall be sent to the consumer                \
 */                                                                            \
static inline _Bool prefix##_producer_commit(prefix##_producer_t *producer) {  \
  pnr_ring_index_t last_published_prod = producer->last_published_prod,        \
    prod = producer->prod;                                                     \
  prefix##_shared_t *shared;                                                   \
  if (prod == last_published_prod)                                             \
    return 0;                                                                  \
  shared = producer->shared;                                                   \
  atomic_store_explicit(&shared->prod, prod, memory_order_release);            \
  /* Make sure that the load from prod_limit is not reordered before the store \
     to prod */                                                                \
  pnr_ring_store_load_fence();                                                 \
  producer->last_published_prod = prod;                                        \
  return (pnr_ring_index_t)(prod - last_published_prod) > (pnr_ring_index_t)   \
    (atomic_load_explicit(&shared->prod_limit, memory_order_relaxed) -         \
    last_published_prod);                                                      \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Initializes the consumer structure. The shared        \
 * structure must be initialized (either by the producer or consumer) before   \
 * any other function is called.                                               \
 * @param consumer a pointer to the consumer's private structure               \
 * @param shared a pointer to the shared structure                             \
 * @param size the size in bytes that the shared structure can use             \
 * @return whether initialization succeeds; it only fails if \p size is too    \
 * small for a shared structure with at least one slot                         \
 */                                                                            \
static inline _Bool prefix##_consumer_init(prefix##_consumer_t *consumer,      \
  prefix##_shared_t *shared, size_t size) {                                    \
  pnr_ring_index_t capacity =                                                  \
    PNR_RING_UNI_SHARED_SIZE_TO_CAPACITY(prefix, size);                        \
  consumer->capacity = capacity;                                               \
  consumer->cons = 0;                                                          \
  consumer->last_published_cons = 0;                                           \
  consumer->cons_end = 0;                                                      \
  consumer->shared = shared;                                                   \
  return capacity != 0;                                                        \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Retrieves the capacity of the ring buffer.            \
 * @param consumer a pointer to the consumer's private structure               \
 * @return the capacity of the ring buffer                                     \
 */                                                                            \
static inline pnr_ring_index_t prefix##_consumer_capacity(                     \
  prefix##_consumer_t *consumer) {                                             \
  return consumer->capacity;                                                   \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Internal helper function. Consumer only. Checks out the unconsumed   \
 * messages in the ring buffer and updates the private state accordingly.      \
 * @param consumer a pointer to the consumer's private structure               \
 * @return whether the ring is not empty                                       \
 */                                                                            \
static inline _Bool prefix##_consumer_checkout_helper(                         \
  prefix##_consumer_t *consumer) {                                             \
  pnr_ring_index_t cons, prod;                                                 \
  cons = consumer->cons;                                                       \
  prod = atomic_load_explicit(&consumer->shared->prod, memory_order_acquire);  \
  /* We can consume until we reach prod. Let us make sure that this is not     \
     more than capacity slots away, i.e. that the producer does not pretend    \
     that it has produced beyond capacity + the private consumer index. Note   \
     that it is actually not supposed to produce beyond capacity + the last    \
     *published* consumer index, but this stricter check would cost a second   \
     comparison */                                                             \
  if ((pnr_ring_index_t)(prod - cons) <= consumer->capacity)                   \
    consumer->cons_end = prod;                                                 \
  return consumer->cons_end != cons;                                           \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Checks out the unconsumed messages in the ring buffer \
 * and updates the private state accordingly. If the ring is empty, asks for a \
 * notification from the producer.                                             \
 * @param consumer a pointer to the consumer's private structure               \
 * @return whether the ring is not empty                                       \
 */                                                                            \
static inline _Bool prefix##_consumer_checkout(                                \
  prefix##_consumer_t *consumer) {                                             \
  if (prefix##_consumer_checkout_helper(consumer))                             \
    /* There are some messages to consume */                                   \
    return 1;                                                                  \
  /* The ring is empty; let the producer know that it needs to notify us when  \
     this changes */                                                           \
  atomic_store_explicit(&consumer->shared->prod_limit, consumer->cons_end,     \
    memory_order_relaxed);                                                     \
  /* Make sure that the next checkout is not reordered before the store to     \
     prod_limit */                                                             \
  pnr_ring_store_load_fence();                                                 \
  /* Check out again, in case the producer produced something between our last \
     checkout and the moment we asked for a notification */                    \
  return prefix##_consumer_checkout_helper(consumer);                          \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Retrieves the number of unconsumed messages in the    \
 * ring buffer.                                                                \
 * @param consumer a pointer to the consumer's private structure               \
 * @return the number of unconsumed messages                                   \
 */                                                                            \
static inline pnr_ring_index_t prefix##_consumer_unconsumed(                   \
  prefix##_consumer_t *consumer) {                                             \
  return consumer->cons_end - consumer->cons;                                  \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Returns a pointer to the first unconsumed message.    \
 * This is a low-level function; consider using *_consumer_consume() instead.  \
 *                                                                             \
 * If there are unconsumed messages, then a pointer to the first one is        \
 * returned. The consumer is then expected to read the message, then call      \
 * *_consumer_advance().                                                       \
 *                                                                             \
 * If there are no unconsumed messages, then \c NULL is returned.              \
 * @param consumer a pointer to the consumer's private structure               \
 * @return a pointer to the first unconsumed message, or \c NULL if there is   \
 * none                                                                        \
 */                                                                            \
static inline msg_t *prefix##_consumer_peek(prefix##_consumer_t *consumer)   { \
  pnr_ring_index_t cons = consumer->cons;                                      \
  return cons == consumer->cons_end ? 0 :                                      \
    &consumer->shared->array[cons & (consumer->capacity - 1)];                 \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Returns the range of unconsumed messages. This is a   \
 * low-level function; consider using *_consumer_consume_n() instead.          \
 *                                                                             \
 * The consumer is then expected to read messages at the beginning of the      \
 * returned range, then call *_consumer_advance_n().                           \
 * @param consumer a pointer to the consumer's private structure               \
 * @return the unconsumed range                                                \
 */                                                                            \
static inline prefix##_range_t prefix##_consumer_peek_all(                     \
  prefix##_consumer_t *consumer) {                                             \
  pnr_ring_range_t untyped_range;                                              \
  prefix##_range_t typed_range;                                                \
  untyped_range = pnr_ring_ranges(sizeof(msg_t), consumer->shared->array,      \
    consumer->capacity, consumer->cons, consumer->cons_end);                   \
  typed_range.fst_begin = untyped_range.fst_begin;                             \
  typed_range.fst_count = untyped_range.fst_count;                             \
  typed_range.snd_begin = untyped_range.snd_begin;                             \
  typed_range.snd_count = untyped_range.snd_count;                             \
  return typed_range;                                                          \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Registers that a message was consumed from the slot   \
 * returned by a previous call to *_consumer_peek(). This is a low-level       \
 * function; consider using *_consumer_consume() instead.                      \
 *                                                                             \
 * The consumer is expected to call *_consumer_commit() at some point to make  \
 * that consumption visible to the producer.                                   \
 * @param consumer a pointer to the consumer's private structure               \
 */                                                                            \
static inline void prefix##_consumer_advance(prefix##_consumer_t *consumer) {  \
  ++consumer->cons;                                                            \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Registers that messages were consumed from the first  \
 * \p count slots returned by a previous call to *_consumer_peek_all().        \
 * This is a low-level function; consider using *_consumer_consume_n()         \
 * instead.                                                                    \
 *                                                                             \
 * The consumer is expected to call *_consumer_commit() at some point to make  \
 * that consumption visible to the producer.                                   \
 * @param consumer a pointer to the consumer's private structure               \
 */                                                                            \
static inline void prefix##_consumer_advance_n(                                \
  prefix##_consumer_t *consumer, pnr_ring_index_t count) {                     \
  consumer->cons += count;                                                     \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Consumes a message.                                   \
 *                                                                             \
 * If there are no unconsumed messages in the ring, returns \c false.          \
 * Otherwise, copies the first one to \c *\p msg, then returns \c true.        \
 *                                                                             \
 * The consumer is expected to call *_consumer_commit() at some point to make  \
 * that consumption visible to the producer.                                   \
 * @param consumer a pointer to the consumer's private structure               \
 * @param msg a pointer to the private message to overwrite                    \
 * @return whether a message was consumed                                      \
 */                                                                            \
static inline _Bool prefix##_consumer_consume(                                 \
  prefix##_consumer_t *consumer, msg_t *msg) {                                 \
  pnr_ring_index_t cons = consumer->cons;                                      \
  if (cons == consumer->cons_end)                                              \
    return 0;                                                                  \
  /* See rationale above for the volatile read */                              \
  *msg = *(msg_t const volatile *)                                             \
    &consumer->shared->array[cons & (consumer->capacity - 1)];                 \
  consumer->cons = cons + 1;                                                   \
  return 1;                                                                    \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Consumes messages.                                    \
 *                                                                             \
 * Copies the unconsumed messages from the ring to the array \p msgs until     \
 * \p count messages have been copied or the ring is empty.                    \
 *                                                                             \
 * The consumer is expected to call *_consumer_commit() at some point to make  \
 * that consumption visible to the producer.                                   \
 * @param consumer a pointer to the consumer's private structure               \
 * @param msgs a pointer to the array of private messages to copy to           \
 * @return the number of messages that were consumed                           \
 */                                                                            \
static inline pnr_ring_index_t prefix##_consumer_consume_n(                    \
  prefix##_consumer_t *consumer, msg_t *msgs, pnr_ring_index_t count) {        \
  return pnr_ring_copy_from_ring(sizeof(msg_t), msgs, count,                   \
    consumer->shared->array, consumer->capacity, consumer->cons,               \
    consumer->cons_end);                                                       \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Consumer only. Makes all of the consumption so far visible to the    \
 * producer.                                                                   \
 * @param consumer a pointer to the consumer's private structure               \
 * @return whether a notification shall be sent to the producer                \
 */                                                                            \
static inline _Bool prefix##_consumer_commit(prefix##_consumer_t *consumer) {  \
  pnr_ring_index_t last_published_cons = consumer->last_published_cons,        \
    cons = consumer->cons;                                                     \
  prefix##_shared_t *shared;                                                   \
  if (cons == last_published_cons)                                             \
    return 0;                                                                  \
  shared = consumer->shared;                                                   \
  atomic_store_explicit(&shared->cons, cons, memory_order_release);            \
  /* Make sure that the load from cons_limit is not reordered before the store \
     to cons */                                                                \
  pnr_ring_store_load_fence();                                                 \
  consumer->last_published_cons = cons;                                        \
  return (pnr_ring_index_t)(cons - last_published_cons) > (pnr_ring_index_t)   \
    (atomic_load_explicit(&shared->cons_limit, memory_order_relaxed) -         \
    last_published_cons);                                                      \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Initializes the shared structure. Must be called either by the       \
 * producer or consumer before any of them starts using the ring buffer        \
 * (except for their own initialization functions).                            \
 * @param shared a pointer to the shared structure                             \
 */                                                                            \
static inline void prefix##_shared_init(prefix##_shared_t *shared) {           \
  atomic_init(&shared->prod, 0);                                               \
  atomic_init(&shared->cons_limit, (pnr_ring_index_t)-1);                      \
  atomic_init(&shared->cons, 0);                                               \
  atomic_init(&shared->prod_limit, 0);                                         \
}

/**
 * @brief Computes the minimal size needed to store the shared structure of a
 * unidirectional ring buffer.
 * @param prefix the prefix used to generate the implementation of the ring
 * buffer
 * @param capacity the capacity of the ring buffer, which must be a power of 2
 * @return the minimal size of the shared structure; it is a compile-time
 * constant if \p capacity is
 */
#define PNR_RING_UNI_CAPACITY_TO_SHARED_SIZE(prefix, capacity)                 \
  (sizeof(prefix##_shared_t) + (capacity) * sizeof(prefix##_message_t))

/**
 * @brief Computes the maximal capacity of a unidirectional ring buffer from the
 * size allowed for its shared structure. If 0 is returned, then there is not
 * enough room for a unidirectional ring buffer.
 * @param prefix the prefix used to generate the implementation of the ring
 * buffer
 * @param size the size allowed for the shared structure
 * @return the maximal capacity of the ring buffer, which is a power of 2 if
 * \p size is large enough to hold a ring with at least one slot, and 0
 * otherwise; it is a compile-time constant if \p size is
 */
#define PNR_RING_UNI_SHARED_SIZE_TO_CAPACITY(prefix, size)                     \
  ((size) >= sizeof(prefix##_shared_t) ? PNR_RING_ROUND_DOWN_POWER2_INDEX(     \
  ((size) - sizeof(prefix##_shared_t)) / sizeof(prefix##_message_t)) :         \
  UINT32_C(0))

/*
 * Bidirectional ring buffers
 */

/**
 * @brief Generates the implementation of a type of bidirectional ring buffer.
 * @param req_t the type of requests
 * @param rsp_t the type of responses
 * @param prefix a prefix for the various identifiers
 */
#define PNR_RING_GENERATE_BI(req_t, rsp_t, prefix)                             \
                                                                               \
/*                                                                             \
 * @brief An alias for the type of requests; useful for macro-generated uses.  \
 */                                                                            \
typedef req_t prefix##_request_t;                                              \
                                                                               \
/*                                                                             \
 * @brief An alias for the type of responses; useful for macro-generated uses. \
 */                                                                            \
typedef rsp_t prefix##_response_t;                                             \
                                                                               \
/*                                                                             \
 * @brief The unsafe blueprint for prefix##_msg_t.                             \
 */                                                                            \
typedef union {                                                                \
  /* The request */                                                            \
  req_t request;                                                               \
  /* The response */                                                           \
  rsp_t response;                                                              \
} prefix##_unsafe_msg_t;                                                       \
                                                                               \
/*                                                                             \
 * @brief A slot in the ring buffer, that holds either a request or a          \
 * response.                                                                   \
 */                                                                            \
typedef union prefix##_msg {                                                   \
  struct {                                                                     \
    /* The request */                                                          \
    req_t request;                                                             \
    PNR_RING_PAD_UMEM(prefix##_unsafe_msg_t, request)                          \
  };                                                                           \
  struct {                                                                     \
    /* The response */                                                         \
    rsp_t response;                                                            \
    PNR_RING_PAD_UMEM(prefix##_unsafe_msg_t, response)                         \
  };                                                                           \
} prefix##_msg_t;                                                              \
                                                                               \
/* Check that all padding was accounted for */                                 \
_Static_assert(sizeof(prefix##_unsafe_msg_t) == sizeof(prefix##_msg_t), "");   \
                                                                               \
/*                                                                             \
 * @brief The unsafe blueprint for prefix##_shared_t.                          \
 */                                                                            \
typedef struct {                                                               \
  /* The index of the next slot in which the client will write */              \
  pnr_ring_index_t _Atomic cprod;                                              \
  /* When sprod strictly passes this value, the server shall notify the        \
     client */                                                                 \
  pnr_ring_index_t _Atomic sprod_limit;                                        \
  /* The index of the next slot in which the server will write */              \
  pnr_ring_index_t _Atomic sprod;                                              \
  /* When cprod strictly passes this value, the client shall notify the        \
     server */                                                                 \
  pnr_ring_index_t _Atomic cprod_limit;                                        \
  /* The message slots */                                                      \
  prefix##_msg_t array[];                                                      \
} prefix##_unsafe_shared_t;                                                    \
                                                                               \
/*                                                                             \
 * @brief The shared structure of the ring.                                    \
 */                                                                            \
typedef struct prefix##_shared {                                               \
  /* The index of the next slot in which the client will write */              \
  pnr_ring_index_t _Atomic cprod;                                              \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, cprod, sprod_limit)              \
  /* When sprod strictly passes this value, the server shall notify the        \
     client */                                                                 \
  pnr_ring_index_t _Atomic sprod_limit;                                        \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, sprod_limit, sprod)              \
  /* The index of the next slot in which the server will write */              \
  pnr_ring_index_t _Atomic sprod;                                              \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, sprod, cprod_limit)              \
  /* When cprod strictly passes this value, the client shall notify the        \
     server */                                                                 \
  pnr_ring_index_t _Atomic cprod_limit;                                        \
  PNR_RING_PAD_2MEM(prefix##_unsafe_shared_t, cprod_limit, array)              \
  /* The message slots */                                                      \
  prefix##_msg_t array[];                                                      \
} prefix##_shared_t;                                                           \
                                                                               \
/* Check that all padding was accounted for */                                 \
_Static_assert(offsetof(prefix##_unsafe_shared_t, array) ==                    \
  offsetof(prefix##_shared_t, array), "");                                     \
                                                                               \
/*                                                                             \
 * @brief The structure private to the client or server.                       \
 */                                                                            \
typedef struct prefix##_private {                                              \
  /* The capacity of the ring */                                               \
  pnr_ring_index_t capacity;                                                   \
  /*                                                                           \
   * The index of the next slot to write; it will be copied to the shared      \
   * structure when we commit                                                  \
   */                                                                          \
  pnr_ring_index_t prod;                                                       \
  /* The most recent value of prod that was copied to the shared structure */  \
  pnr_ring_index_t last_published_prod;                                        \
  /*                                                                           \
   * The index of the next slot to read; it is set up such that we can produce \
   * until prod == cons; which means that for the client it is artificially    \
   * incremented by capacity                                                   \
   */                                                                          \
  pnr_ring_index_t cons;                                                       \
  /* An index such that we may consume until cons == cons_end */               \
  pnr_ring_index_t cons_end;                                                   \
  /* A pointer to the shared structure */                                      \
  prefix##_shared_t *shared;                                                   \
} prefix##_private_t;                                                          \
                                                                               \
/*                                                                             \
 * @brief The structure private to the client; a simple wrapper for stronger   \
 * typing.                                                                     \
 */                                                                            \
typedef struct prefix##_client {                                               \
  /* The wrapped structure */                                                  \
  prefix##_private_t s;                                                        \
} prefix##_client_t;                                                           \
                                                                               \
/*                                                                             \
 * @brief The structure private to the server; a simple wrapper for stronger   \
 * typing.                                                                     \
 */                                                                            \
typedef struct prefix##_server {                                               \
  /* The wrapped structure */                                                  \
  prefix##_private_t s;                                                        \
} prefix##_server_t;                                                           \
                                                                               \
/*                                                                             \
 * @brief Client only. Initializes the client structure. The shared structure  \
 * must be initialized (either by the client or server) before any other       \
 * function is called.                                                         \
 * @param client a pointer to the client's private structure                   \
 * @param shared a pointer to the shared structure                             \
 * @param size the size in bytes that the shared structure can use             \
 * @return whether initialization succeeds; it only fails if \p size is too    \
 * small for a shared structure with at least one slot                         \
 */                                                                            \
static inline _Bool prefix##_client_init(prefix##_client_t *client,            \
  prefix##_shared_t *shared, size_t size) {                                    \
  pnr_ring_index_t capacity =                                                  \
    PNR_RING_BI_SHARED_SIZE_TO_CAPACITY(prefix, size);                         \
  client->s.capacity = capacity;                                               \
  client->s.prod = 0;                                                          \
  client->s.last_published_prod = 0;                                           \
  client->s.cons = capacity;                                                   \
  client->s.cons_end = capacity;                                               \
  client->s.shared = shared;                                                   \
  return capacity != 0;                                                        \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Retrieves the capacity of the ring buffer.              \
 * @param client a pointer to the client's private structure                   \
 * @return the capacity of the ring buffer                                     \
 */                                                                            \
static inline pnr_ring_index_t prefix##_client_capacity(                       \
  prefix##_client_t *client) {                                                 \
  return client->s.capacity;                                                   \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Internal helper function. Client only. Checks out the unconsumed     \
 * responses in the ring buffer and updates the private state accordingly.     \
 * @param client a pointer to the client's private structure                   \
 * @return whether the ring has unconsumed responses                           \
 */                                                                            \
static inline _Bool prefix##_client_checkout_helper(                           \
  prefix##_client_t *client) {                                                 \
  pnr_ring_index_t ccons, capacity, real_ccons, sprod;                         \
  ccons = client->s.cons;                                                      \
  capacity = client->s.capacity;                                               \
  /* The client's cons index is artificially positioned capacity elements      \
     ahead */                                                                  \
  real_ccons = ccons - capacity;                                               \
  sprod = atomic_load_explicit(&client->s.shared->sprod,                       \
    memory_order_acquire);                                                     \
  /* If the server pretends it has produced beyond the client's published      \
     producer index, then something is wrong */                                \
  if ((pnr_ring_index_t)(sprod - real_ccons) <=                                \
    (pnr_ring_index_t)(client->s.last_published_prod - real_ccons))            \
    client->s.cons_end = sprod + capacity;                                     \
  return client->s.cons_end != ccons;                                          \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Checks out the unconsumed responses in the ring buffer  \
 * and updates the private state accordingly. If there are no unconsumed       \
 * responses, asks for a notification from the server.                         \
 * @param client a pointer to the client's private structure                   \
 * @return whether the ring has unconsumed responses                           \
 */                                                                            \
static inline _Bool prefix##_client_checkout(prefix##_client_t *client) {      \
  if (prefix##_client_checkout_helper(client))                                 \
    /* There are responses to consume */                                       \
    return 1;                                                                  \
  /* There are no responses; let the server know that it needs to notify us    \
     when this changes */                                                      \
  atomic_store_explicit(&client->s.shared->sprod_limit, client->s.cons_end -   \
    client->s.capacity, memory_order_relaxed);                                 \
  /* Make sure that the next checkout is not reordered before the store to     \
     sprod_limit */                                                            \
  pnr_ring_store_load_fence();                                                 \
  /* Check out again, in case the server produced some responses between our   \
     last checkout and the moment we asked for a notification */               \
  return prefix##_client_checkout_helper(client);                              \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Retrieves the number of unconsumed responses in the     \
 * ring buffer.                                                                \
 * @param client a pointer to the client's private structure                   \
 * @return the number of unconsumed responses                                  \
 */                                                                            \
static inline pnr_ring_index_t prefix##_client_unconsumed(                     \
  prefix##_client_t *client) {                                                 \
  return client->s.cons_end - client->s.cons;                                  \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Returns a pointer to the first unconsumed response.     \
 * This is a low-level function; consider using *_client_consume() instead.    \
 *                                                                             \
 * If there are unconsumed responses, then a pointer to the first one is       \
 * returned. The client is then expected to read the response, then call       \
 * *_client_advance_cons().                                                    \
 *                                                                             \
 * If there are no unconsumed responses, then \c NULL is returned.             \
 * @param client a pointer to the client's private structure                   \
 * @return a pointer to the first unconsumed response, or \c NULL if there is  \
 * none                                                                        \
 */                                                                            \
static inline rsp_t *prefix##_client_peek_cons(                                \
  prefix##_client_t *client) {                                                 \
  pnr_ring_index_t cons = client->s.cons;                                      \
  return cons == client->s.cons_end ? 0 :                                      \
    &client->s.shared->array[cons & (client->s.capacity - 1)].response;        \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Registers that a response was consumed from the slot    \
 * returned by a previous call to *_client_peek_cons(). This is a low-level    \
 * function; consider using *_client_consume() instead.                        \
 * @param client a pointer to the client's private structure                   \
 */                                                                            \
static inline void prefix##_client_advance_cons(prefix##_client_t *client) {   \
  ++client->s.cons;                                                            \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Consumes a response.                                    \
 *                                                                             \
 * If there are no unconsumed responses in the ring, returns \c false.         \
 * Otherwise, copies the first one to \c *\p rsp, then returns \c true.        \
 * @param client a pointer to the client's private structure                   \
 * @param rsp a pointer to the private response to overwrite                   \
 * @return whether a response was consumed                                     \
 */                                                                            \
static inline _Bool prefix##_client_consume(prefix##_client_t *client,         \
  rsp_t *rsp) {                                                                \
  pnr_ring_index_t cons = client->s.cons;                                      \
  if (cons == client->s.cons_end)                                              \
    return 0;                                                                  \
  /* See rationale above for the volatile read */                              \
  *rsp = *(rsp_t const volatile *)                                             \
    &client->s.shared->array[cons & (client->s.capacity - 1)].response;        \
  client->s.cons = cons + 1;                                                   \
  return 1;                                                                    \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Retrieves the number of slots available for request     \
 * production in the ring buffer.                                              \
 * @param client a pointer to the client's private structure                   \
 * @return the number of slots available for request production                \
 */                                                                            \
static inline pnr_ring_index_t prefix##_client_free(                           \
  prefix##_client_t *client) {                                                 \
  return client->s.cons - client->s.prod;                                      \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Returns a pointer to the first free slot in which to    \
 * write a request. This is a low-level function; consider using               \
 * *_client_produce() instead.                                                 \
 *                                                                             \
 * If there is room for a new request, then a pointer to the first free slot   \
 * is returned. The client is then expected to write the request, then call    \
 * *_client_advance_prod().                                                    \
 *                                                                             \
 * If there is no room for a new request, then \c NULL is returned.            \
 * @param client a pointer to the client's private structure                   \
 * @return a pointer to the first free request slot, or \c NULL if there is    \
 * none                                                                        \
 */                                                                            \
static inline req_t *prefix##_client_peek_prod(                                \
  prefix##_client_t *client) {                                                 \
  pnr_ring_index_t prod = client->s.prod;                                      \
  return prod == client->s.cons ? 0 :                                          \
    &client->s.shared->array[prod & (client->s.capacity - 1)].request;         \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Registers that a request was produced in the slot       \
 * returned by a previous call to *_client_peek_prod(). This is a low-level    \
 * function; consider using *_client_produce() instead.                        \
 *                                                                             \
 * The client is expected to call *_client_commit() at some point to make that \
 * production visible to the server.                                           \
 * @param client a pointer to the client's private structure                   \
 */                                                                            \
static inline void prefix##_client_advance_prod(prefix##_client_t *client) {   \
  ++client->s.prod;                                                            \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Produces a request.                                     \
 *                                                                             \
 * If there are no free request slots in the ring, returns \c false.           \
 * Otherwise, copies \c *\p req to the ring, then returns \c true.             \
 *                                                                             \
 * The client is expected to call *_client_commit() at some point to make that \
 * production visible to the server.                                           \
 * @param client a pointer to the client's private structure                   \
 * @param req a pointer to the private request to copy                         \
 * @return whether a request was produced                                      \
 */                                                                            \
static inline _Bool prefix##_client_produce(                                   \
  prefix##_client_t *client, req_t const *req) {                               \
  pnr_ring_index_t prod = client->s.prod;                                      \
  if (prod == client->s.cons)                                                  \
    return 0;                                                                  \
  client->s.shared->array[prod & (client->s.capacity - 1)].request = *req;     \
  client->s.prod = prod + 1;                                                   \
  return 1;                                                                    \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Client only. Makes all of the request production so far visible to   \
 * the server.                                                                 \
 * @param client a pointer to the client's private structure                   \
 * @return whether a notification shall be sent to the server                  \
 */                                                                            \
static inline _Bool prefix##_client_commit(prefix##_client_t *client) {        \
  pnr_ring_index_t last_published_prod = client->s.last_published_prod,        \
    prod = client->s.prod;                                                     \
  prefix##_shared_t *shared;                                                   \
  if (prod == last_published_prod)                                             \
    return 0;                                                                  \
  shared = client->s.shared;                                                   \
  atomic_store_explicit(&shared->cprod, prod, memory_order_release);           \
  /* Make sure that the load from cprod_limit is not reordered before the      \
     store to cprod */                                                         \
  pnr_ring_store_load_fence();                                                 \
  client->s.last_published_prod = prod;                                        \
  return (pnr_ring_index_t)(prod - last_published_prod) > (pnr_ring_index_t)   \
    (atomic_load_explicit(&shared->cprod_limit, memory_order_relaxed) -        \
    last_published_prod);                                                      \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Initializes the server structure. The shared structure  \
 * must be initialized (either by the client or server) before any other       \
 * function is called.                                                         \
 * @param server a pointer to the server's private structure                   \
 * @param shared a pointer to the shared structure                             \
 * @param size the size in bytes that the shared structure can use             \
 * @return whether initialization succeeds; it only fails if \p size is too    \
 * small for a shared structure with at least one slot                         \
 */                                                                            \
static inline _Bool prefix##_server_init(prefix##_server_t *server,            \
  prefix##_shared_t *shared, size_t size) {                                    \
  pnr_ring_index_t capacity =                                                  \
    PNR_RING_BI_SHARED_SIZE_TO_CAPACITY(prefix, size);                         \
  server->s.capacity = capacity;                                               \
  server->s.prod = 0;                                                          \
  server->s.last_published_prod = 0;                                           \
  server->s.cons = 0;                                                          \
  server->s.cons_end = 0;                                                      \
  server->s.shared = shared;                                                   \
  return capacity != 0;                                                        \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Retrieves the capacity of the ring buffer.              \
 * @param server a pointer to the server's private structure                   \
 * @return the capacity of the ring buffer                                     \
 */                                                                            \
static inline pnr_ring_index_t prefix##_server_capacity(                       \
  prefix##_server_t *server) {                                                 \
  return server->s.capacity;                                                   \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Internal helper function. Server only. Checks out the unconsumed     \
 * requests in the ring buffer and updates the private state accordingly.      \
 * @param server a pointer to the server's private structure                   \
 * @return whether the ring has unconsumed requests                            \
 */                                                                            \
static inline _Bool prefix##_server_checkout_helper(                           \
  prefix##_server_t *server) {                                                 \
  pnr_ring_index_t scons, cprod;                                               \
  scons = server->s.cons;                                                      \
  cprod = atomic_load_explicit(&server->s.shared->cprod,                       \
    memory_order_acquire);                                                     \
  /* If the client pretends it has produced beyond capacity + the server's     \
     published producer index, then something is wrong */                      \
  if ((pnr_ring_index_t)(cprod - scons) <= (pnr_ring_index_t)                  \
    (server->s.last_published_prod + server->s.capacity - scons))              \
    server->s.cons_end = cprod;                                                \
  return server->s.cons_end != scons;                                          \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Checks out the unconsumed requests in the ring buffer   \
 * and updates the private state accordingly. If there are no unconsumed       \
 * requests, asks for a notification from the client.                          \
 * @param server a pointer to the server's private structure                   \
 * @return whether the ring has unconsumed requests                            \
 */                                                                            \
static inline _Bool prefix##_server_checkout(prefix##_server_t *server) {      \
  if (prefix##_server_checkout_helper(server))                                 \
    /* There are requests to consume */                                        \
    return 1;                                                                  \
  /* There are no requests; let the client know that it needs to notify us     \
     when this changes */                                                      \
  atomic_store_explicit(&server->s.shared->cprod_limit, server->s.cons_end,    \
    memory_order_relaxed);                                                     \
  /* Make sure that the next checkout is not reordered before the store to     \
     cprod_limit */                                                            \
  pnr_ring_store_load_fence();                                                 \
  /* Check out again, in case the client produced some responses between our   \
     last checkout and the moment we asked for a notification */               \
  return prefix##_server_checkout_helper(server);                              \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Retrieves the number of unconsumed requests in the      \
 * ring buffer.                                                                \
 * @param server a pointer to the server's private structure                   \
 * @return the number of unconsumed requests                                   \
 */                                                                            \
static inline pnr_ring_index_t prefix##_server_unconsumed(                     \
  prefix##_server_t *server) {                                                 \
  return server->s.cons_end - server->s.cons;                                  \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Returns a pointer to the first unconsumed request.      \
 * This is a low-level function; consider using *_server_consume() instead.    \
 *                                                                             \
 * If there are unconsumed requests, then a pointer to the first one is        \
 * returned. The server is then expected to read the request, then call        \
 * *_server_advance_cons().                                                    \
 *                                                                             \
 * If there are no unconsumed requests, then \c NULL is returned.              \
 * @param server a pointer to the server's private structure                   \
 * @return a pointer to the first unconsumed request, or \c NULL if there is   \
 * none                                                                        \
 */                                                                            \
static inline req_t *prefix##_server_peek_cons(                                \
  prefix##_server_t *server) {                                                 \
  pnr_ring_index_t cons = server->s.cons;                                      \
  return cons == server->s.cons_end ? 0 :                                      \
    &server->s.shared->array[cons & (server->s.capacity - 1)].request;         \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Registers that a request was consumed from the slot     \
 * returned by a previous call to *_server_peek_cons(). This is a low-level    \
 * function; consider using *_server_consume() instead.                        \
 * @param server a pointer to the server's private structure                   \
 */                                                                            \
static inline void prefix##_server_advance_cons(prefix##_server_t *server) {   \
  ++server->s.cons;                                                            \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Consumes a request.                                     \
 *                                                                             \
 * If there are no unconsumed requests in the ring, returns \c false.          \
 * Otherwise, copies the first one to \c *\p req, then returns \c true.        \
 * @param server a pointer to the server's private structure                   \
 * @param req a pointer to the private request to overwrite                    \
 * @return whether a request was consumed                                      \
 */                                                                            \
static inline _Bool prefix##_server_consume(prefix##_server_t *server,         \
  req_t *req) {                                                                \
  pnr_ring_index_t cons = server->s.cons;                                      \
  if (cons == server->s.cons_end)                                              \
    return 0;                                                                  \
  /* See rationale above for the volatile read */                              \
  *req = *(req_t volatile *)                                                   \
    &server->s.shared->array[cons & (server->s.capacity - 1)].request;         \
  server->s.cons = cons + 1;                                                   \
  return 1;                                                                    \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Retrieves the number of slots available for response    \
 * production in the ring buffer.                                              \
 * @param server a pointer to the server's private structure                   \
 * @return the number of slots available for response production               \
 */                                                                            \
static inline pnr_ring_index_t prefix##_server_free(                           \
  prefix##_server_t *server) {                                                 \
  return server->s.cons - server->s.prod;                                      \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Returns a pointer to the first free slot in which to    \
 * write a response. This is a low-level function; consider using              \
 * *_server_produce() instead.                                                 \
 *                                                                             \
 * If there is room for a new response, then a pointer to the first free slot  \
 * is returned. The server is then expected to write the response, then call   \
 * *_server_advance_prod().                                                    \
 *                                                                             \
 * If there is no room for a new response, then \c NULL is returned.           \
 * @param server a pointer to the server's private structure                   \
 * @return a pointer to the first free response slot, or \c NULL if there is   \
 * none                                                                        \
 */                                                                            \
static inline rsp_t *prefix##_server_peek_prod(                                \
  prefix##_server_t *server) {                                                 \
  pnr_ring_index_t prod = server->s.prod;                                      \
  return prod == server->s.cons ? 0 :                                          \
    &server->s.shared->array[prod & (server->s.capacity - 1)].response;        \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Registers that a response was produced in the slot      \
 * returned by a previous call to *_server_peek_prod(). This is a low-level    \
 * function; consider using *_server_produce() instead.                        \
 *                                                                             \
 * The server is expected to call *_server_commit() at some point to make that \
 * production visible to the client.                                           \
 * @param server a pointer to the server's private structure                   \
 */                                                                            \
static inline void prefix##_server_advance_prod(prefix##_server_t *server) {   \
  ++server->s.prod;                                                            \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Produces a response.                                    \
 *                                                                             \
 * If there are no free response slots in the ring, returns \c false.          \
 * Otherwise, copies \c *\p rsp to the ring, then returns \c true.             \
 *                                                                             \
 * The server is expected to call *_server_commit() at some point to make that \
 * production visible to the client.                                           \
 * @param server a pointer to the server's private structure                   \
 * @param rsp a pointer to the private response to copy                        \
 * @return whether a response was produced                                     \
 */                                                                            \
static inline _Bool prefix##_server_produce(                                   \
  prefix##_server_t *server, rsp_t const *rsp) {                               \
  pnr_ring_index_t prod = server->s.prod;                                      \
  if (prod == server->s.cons)                                                  \
    return 0;                                                                  \
  server->s.shared->array[prod & (server->s.capacity - 1)].response = *rsp;    \
  server->s.prod = prod + 1;                                                   \
  return 1;                                                                    \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Server only. Makes all of the response production so far visible to  \
 * the client.                                                                 \
 * @param server a pointer to the server's private structure                   \
 * @return whether a notification shall be sent to the client                  \
 */                                                                            \
static inline _Bool prefix##_server_commit(prefix##_server_t *server) {        \
  pnr_ring_index_t last_published_prod = server->s.last_published_prod,        \
    prod = server->s.prod;                                                     \
  prefix##_shared_t *shared;                                                   \
  if (prod == last_published_prod)                                             \
    return 0;                                                                  \
  shared = server->s.shared;                                                   \
  atomic_store_explicit(&shared->sprod, prod, memory_order_release);           \
  /* Make sure that the load from sprod_limit is not reordered before the      \
     store to sprod */                                                         \
  pnr_ring_store_load_fence();                                                 \
  server->s.last_published_prod = prod;                                        \
  return (pnr_ring_index_t)(prod - last_published_prod) > (pnr_ring_index_t)   \
    (atomic_load_explicit(&shared->sprod_limit, memory_order_relaxed) -        \
    last_published_prod);                                                      \
}                                                                              \
                                                                               \
/*                                                                             \
 * @brief Initializes the shared structure. Must be called either by the       \
 * client or server before any of them starts using the ring buffer (except    \
 * for their own initialization functions).                                    \
 * @param shared a pointer to the shared structure                             \
 */                                                                            \
static inline void prefix##_shared_init(prefix##_shared_t *shared) {           \
  atomic_init(&shared->cprod, 0);                                              \
  atomic_init(&shared->sprod_limit, 0);                                        \
  atomic_init(&shared->sprod, 0);                                              \
  atomic_init(&shared->cprod_limit, 0);                                        \
}

/**
 * @brief Computes the minimal size needed to store the shared structure of a
 * bidirectional ring buffer.
 * @param prefix the prefix used to generate the implementation of the ring
 * buffer
 * @param capacity the capacity of the ring buffer, which must be a power of 2
 * @return the minimal size of the shared structure; it is a compile-time
 * constant if \p capacity is
 */
#define PNR_RING_BI_CAPACITY_TO_SHARED_SIZE(prefix, capacity)                  \
  (sizeof(prefix##_shared_t) + (capacity) * sizeof(prefix##_msg_t))

/**
 * @brief Computes the maximal capacity of a bidirectional ring buffer from the
 * size allowed for its shared structure. If 0 is returned, then there is not
 * enough room for a bidirectional ring buffer.
 * @param prefix the prefix used to generate the implementation of the ring
 * buffer
 * @param size the size allowed for the shared structure
 * @return the maximal capacity of the ring buffer, which is a power of 2 if
 * \p size is large enough to hold a ring with at least one slot, and 0
 * otherwise; it is a compile-time constant if \p size is
 */
#define PNR_RING_BI_SHARED_SIZE_TO_CAPACITY(prefix, size)                      \
  ((size) >= sizeof(prefix##_shared_t) ? PNR_RING_ROUND_DOWN_POWER2_INDEX(     \
  ((size) - sizeof(prefix##_shared_t)) / sizeof(prefix##_msg_t)) : UINT32_C(0))

#endif // PNR_RING_H
